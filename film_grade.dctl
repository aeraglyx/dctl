DEFINE_UI_PARAMS(EXPOSURE, Exposure, DCTLUI_SLIDER_FLOAT, 0.0, -4, 4, 0.001);
DEFINE_UI_PARAMS(CONTRAST, Contrast, DCTLUI_SLIDER_FLOAT, 0.85, 0.5, 1, 0.001);

DEFINE_UI_PARAMS(TEMP, Temperature, DCTLUI_SLIDER_FLOAT, 0.0, -1, 1, 0.001);
DEFINE_UI_PARAMS(TINT, Tint, DCTLUI_SLIDER_FLOAT, 0.0, -1, 1, 0.001);

DEFINE_UI_PARAMS(SATURATION, Saturation, DCTLUI_SLIDER_FLOAT, 1.125, 0, 2, 0.001);
DEFINE_UI_PARAMS(HL_DESAT, Desaturate Highlights, DCTLUI_SLIDER_FLOAT, 0.5, 0, 2, 0.001);
DEFINE_UI_PARAMS(SAT_OFFSET, Sat Offset, DCTLUI_SLIDER_FLOAT, 0.5, 0, 2, 0.001);

DEFINE_UI_PARAMS(TYPE, Type, DCTLUI_COMBO_BOX, 0, { AVG, LEN }, { Avg, Length} )


__DEVICE__ float3 exposure(float3 rgb, float stops) {
	
	const float e = pow(2.0f, stops);
	
	float r = rgb.x * e;
	float g = rgb.y * e;
	float b = rgb.z * e;

	return make_float3(r, g, b);
}

__DEVICE__ float3 white_balance(float3 rgb, float temp, float tint) {

	float r = rgb.x * (1.0f + 1.0f/2.0f * temp + 1.0f/3.0f * tint);
	float g = rgb.y * (1.0f                    - 2.0f/3.0f * tint);
	float b = rgb.z * (1.0f - 1.0f/2.0f * temp + 1.0f/3.0f * tint);

	return make_float3(r, g, b);
}

__DEVICE__ float black_and_white(float3 rgb) {
	// float bw;
	// if (TYPE == AVG) {
	// 	bw = (rgb.x + rgb.y + rgb.z) / 3.0f;
	// }
	// else if (TYPE == LEN) {
	// 	float bw = sqrt(pow(rgb.x, 2.0f) + pow(rgb.y, 2.0f) + pow(rgb.z, 2.0f));
	// return sqrt(pow(rgb.x, 2.0f) + pow(rgb.y, 2.0f) + pow(rgb.z, 2.0f));
	return (rgb.x + rgb.y + rgb.z) / 3.0f;
}

__DEVICE__ float3 saturation(float3 rgb, float sat) {
	
	// float bw = (rgb.x + rgb.y + rgb.z) / 3.0f;  // TODO better luma method
	float bw = black_and_white(rgb);

	float r = sat * rgb.x + (1 - sat) * bw;
	float g = sat * rgb.y + (1 - sat) * bw;
	float b = sat * rgb.z + (1 - sat) * bw;

	return make_float3(r, g, b);
}

__DEVICE__ float3 highlight_desat(float3 rgb, float saturation, float strength, float sat_offset) {
	
	// float bw = (rgb.x + rgb.y + rgb.z) / 3.0f;
	float bw = black_and_white(rgb);  // TODO to main (calculated twice)
	float sat = saturation * exp(- strength * (bw - sat_offset));
	
	float r = sat * rgb.x + (1 - sat) * bw;
	float g = sat * rgb.y + (1 - sat) * bw;
	float b = sat * rgb.z + (1 - sat) * bw;

	return make_float3(r, g, b);
}

__DEVICE__ float3 naka_rushton(float3 rgb, float strength) {
	
	// const float strength;  // 0-1, 0.5 -> rh
	const float power = tan(1.57079633 * strength);  // 0.25 * tau * strength

	const float h = 0.5f;
	
	float r = pow(rgb.x, power) / (pow(rgb.x, power) + pow(h, power));
	float g = pow(rgb.y, power) / (pow(rgb.y, power) + pow(h, power));
	float b = pow(rgb.z, power) / (pow(rgb.z, power) + pow(h, power));

	return make_float3(r, g, b);
}






__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {	
	
	float3 rgb = make_float3(p_R, p_G, p_B);

	// if (TYPE == AVG) {
	// 	float bw = (rgb.x + rgb.y + rgb.z) / 3.0f;
	// }
	// else if (TYPE == LEN) {
	// 	float bw = sqrt(pow(rgb.x, 2.0f) + pow(rgb.y, 2.0f) + pow(rgb.z, 2.0f));
	// }

	rgb = exposure(rgb, EXPOSURE);
	rgb = saturation(rgb, SATURATION);
	rgb = white_balance(rgb, TEMP, TINT);
	// // TODO grade
	// // TODO grain ?
	rgb = highlight_desat(rgb, 1.0f, HL_DESAT, SAT_OFFSET);
	rgb = naka_rushton(rgb, CONTRAST);
	// TODO fog ?

	return rgb;
}